# Task 5.3: 効果音再生サービスの実装

## 実装予測（Plan モードでの分析）
- expo-av の `Audio.Sound` API を使ったラッパーサービスを関数ベースで作成（speech-synthesis.ts と同パターン）
- 予測した変更対象ファイル:
  - `src/features/voice/services/sound.ts`（新規）
  - `src/features/voice/services/__tests__/sound.test.ts`（新規）
  - `__mocks__/expo-av.js`（新規）
  - `assets/sounds/whistle.mp3`（新規・アセット）
  - `package.json` / `bun.lock`（expo-av 依存追加）
- Contract 準拠: `preload(): Promise<void>` / `play(type: SoundType): Promise<void>`
- エラー戦略: design.md「効果音ファイル読み込み失敗 → エラーログ出力、音なしで続行」に従い Graceful Degradation
- モック設計: `__mocks__/expo-av.js` にテストヘルパー（`__triggerPlaybackFinished()`, `__resetState()` 等）を配置。既存の expo-speech モックと同じパターン

## 実施内容
- tasks.md の「5.3 (P) 効果音再生サービスの実装」を実施

## 実装結果（spec-impl の実際の出力）
- 作成/変更ファイル:
  - `package.json` / `bun.lock` — expo-av@15.0.2 追加
  - `__mocks__/expo-av.js` — expo-av の Jest モック + テストヘルパー（新規）
  - `__mocks__/audio-file.js` — .mp3/.wav/.ogg アセットの Jest モック（新規）
  - `src/features/voice/services/sound.ts` — SoundService 本体（新規）
  - `src/features/voice/services/__tests__/sound.test.ts` — ユニットテスト 11件（新規）
  - `assets/sounds/.gitkeep` — サウンドアセットディレクトリ placeholder（新規）
  - `.kiro/specs/voice-scoreboard/tasks.md` — 5.3 を完了にマーク
- 主な技術的決定:
  - `Audio.Sound.createAsync()` でプリロード → `playAsync()` で再生 → `setOnPlaybackStatusUpdate` の `didJustFinish: true` で完了検知
  - 再生完了後に `stopAsync()` で再生位置を先頭にリセット（次回再生に備える）
  - `preload()` は冪等（`isPreloaded` フラグで2回目以降をスキップ）
  - `play()` はプリロード未実行でも自動プリロードする堅牢設計
  - テスト結果: 11/11 PASS、全体リグレッションなし

## 予測との乖離
- **アセットモックの追加が必要だった**: `require('...whistle.mp3')` が Jest 環境で解決できないため、`__mocks__/audio-file.js` と `package.json` の `moduleNameMapper` に `.mp3/.wav/.ogg` マッピングを追加。予測では触れていなかった
- **モジュールレベル状態のテスト間リーク**: 予測では `jest.isolateModules()` を候補に挙げていたが、実際には `_resetForTesting()` エクスポート関数方式を採用。Jest がモジュールを1回だけロードするため、`isPreloaded` / `soundCache` が全テストで共有される問題が発生
- **microtask drain の必要性**: `play()` 内の `await preload()` → `await createAsync()` の非同期チェーンにより、テスト側で `__triggerPlaybackFinished()` を呼ぶ前に `await Promise.resolve()` を2回挿入して microtask を drain する必要があった
- ホイッスル音 MP3 ファイルは TDD 段階では不要（モックで動作）のため、`.gitkeep` のみ配置。実ファイルは M4 検証前に用意する

## 意思決定ログ
| 選択肢 | 採用 | 理由 |
|--------|------|------|
| `jest.isolateModules()` vs `_resetForTesting()` | `_resetForTesting()` | isolateModules はモック設定が複雑化する。既存の speech-recognition.ts もモジュールレベル状態を持ち、テスト側でリセットするパターンを採用している |
| `Audio.Sound.createAsync()` + キャッシュ vs 毎回ロード | キャッシュ | プリロードした Sound インスタンスを再利用し、試合終了時の再生遅延を回避 |
| 再生完了検知: `didJustFinish` vs タイマー | `didJustFinish` | expo-av 公式 API で正確な完了検知が可能。タイマーは音声長との同期が不正確 |
| エラー時の挙動: 例外スロー vs Graceful Degradation | Graceful Degradation | design.md のエラー戦略に準拠。効果音は UX 補助であり、失敗しても試合進行を妨げない |
| `setOnPlaybackStatusUpdate(null)` + `stopAsync()` vs `unloadAsync()` | stopAsync | unloadAsync は再ロードが必要になるが、stopAsync は位置リセットのみで次回再生が即座に可能 |

## 学び（Lessons Learned）
- Jest 環境で `require('...mp3')` を解決するには `moduleNameMapper` でアセットファイルのモックが必要。CSS モック（`__mocks__/css.js`）と同様のパターンで `__mocks__/audio-file.js` を追加する
- `async function` 内の `await` チェーンが複数段ある場合、テスト側で同期的にトリガーを呼ぶと microtask が未解決でコールバックが登録されていない。`await Promise.resolve()` を挟んで drain する必要がある
- expo-av の `Audio.Sound.createAsync()` は `{ sound }` を返す destructuring パターン。モックでは `mockResolvedValue({ sound: mockInstance })` で再現する
