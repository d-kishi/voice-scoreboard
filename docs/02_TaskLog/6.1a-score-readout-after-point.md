# Task 6.1a: 得点加算時のスコア読み上げ対応（仕様変更）

## 実装予測（Plan モードでの分析）
- 現行仕様（Req 6.4）を廃止し、全コマンドで「Roger」→ スコア操作 →「左x点 右y点」と読み上げるよう変更
- `voice-state-reducer.ts`: `COMMAND_EXECUTED` アクションを削除（デッドコード化）
- `use-voice-state-machine.ts`: right/left の dispatch を `COMMAND_EXECUTED` → `COMMAND_EXECUTED_WITH_SCORE` に変更
- テスト: 「得点加算時はスコア読み上げなし」→「得点加算時もスコア読み上げ」に反転
- リスク: 低（dispatch するアクション名の変更のみ。`COMMAND_EXECUTED_WITH_SCORE` は既に実装済み）

## 実施内容
- tasks.md の Task 6.1a: 得点加算時のスコア読み上げ対応（仕様変更）
  - requirements.md Req 6.3 を全コマンド対象に拡大、Req 6.4 を削除
  - design.md の状態マシン図を `EXECUTING --> SPEAKING_SCORE` に統一
  - reducer から `COMMAND_EXECUTED` アクションを削除
  - hook の `executeCommand()` で全コマンド共通の `COMMAND_EXECUTED_WITH_SCORE` を dispatch
  - テスト更新: 得点加算時もスコア読み上げが行われることを検証
- _Requirements: 6.3_

## 実装結果

### 作成/変更ファイル
| ファイル | 操作 | 役割 |
|---------|------|------|
| `.kiro/specs/voice-scoreboard/requirements.md` | 変更 | Req 6.3 を全コマンド対象に拡大、Req 6.4 を削除 |
| `.kiro/specs/voice-scoreboard/design.md` | 変更 | 状態マシン図: `EXECUTING --> SPEAKING_SCORE` に統一（得点加算 → IDLE 経路を廃止） |
| `.kiro/specs/voice-scoreboard/tasks.md` | 変更 | Task 6.1a 追加・完了マーク |
| `src/features/voice/hooks/voice-state-reducer.ts` | 変更 | `COMMAND_EXECUTED` アクションを型定義・case ブロックから削除 |
| `src/features/voice/hooks/use-voice-state-machine.ts` | 変更 | `executeCommand()`: right/left でも `COMMAND_EXECUTED_WITH_SCORE` を dispatch。switch 後に共通 dispatch |
| `src/features/voice/hooks/__tests__/voice-state-reducer.test.ts` | 変更 | `COMMAND_EXECUTED` テストを削除し、`COMMAND_EXECUTED_WITH_SCORE` の得点加算時テストを追加 |
| `src/features/voice/hooks/__tests__/use-voice-state-machine.test.ts` | 変更 | 得点加算フローのテスト 4 件を SPEAKING_SCORE 経由に変更。isSpeechEnabled=false テストのコメント修正 |

### テスト結果
- `voice-state-reducer.test.ts`: PASS（変更後も全ケース pass）
- `use-voice-state-machine.test.ts`: PASS（変更後も全ケース pass）
- 全体: 21 スイート、325 テスト PASS（リグレッションなし）

### テストケース一覧

#### voice-state-reducer: EXECUTING 状態（3テスト → 変更後 3テスト）
| ケース | 期待値 |
|--------|--------|
| COMMAND_EXECUTED_WITH_SCORE で SPEAKING_SCORE に遷移する（得点加算時） | state: SPEAKING_SCORE |
| COMMAND_EXECUTED_WITH_SCORE で SPEAKING_SCORE に遷移する（ロールバック時） | state: SPEAKING_SCORE |
| COMMAND_EXECUTED_WITH_SCORE で pendingCommand がクリアされる | pendingCommand: null |

#### use-voice-state-machine: コマンド実行フロー（得点加算）（6テスト → 変更後 6テスト）
| ケース | 期待値 |
|--------|--------|
| 「右」検知で SPEAKING_ROGER に遷移する | state: SPEAKING_ROGER |
| SPEAKING_ROGER で abortRecognition が呼ばれる（排他制御） | abortRecognition 呼出 |
| SPEAKING_ROGER で speakRoger が呼ばれる | speakRoger 呼出 |
| Roger 完了で EXECUTING → incrementScore → SPEAKING_SCORE → スコア読み上げ → IDLE | incrementScore('right'), speakScore 呼出, 最終 state: IDLE |
| 「左」検知で incrementScore(left) → SPEAKING_SCORE → IDLE | incrementScore('left'), state: SPEAKING_SCORE → IDLE |
| interim result でもコマンドを検知する | state: SPEAKING_ROGER |
| 得点加算時もスコア読み上げが行われる | speakScore(3, 2, fn), state: SPEAKING_SCORE |

#### use-voice-state-machine: 設定反映（変更 1テスト）
| ケース | 期待値 |
|--------|--------|
| isSpeechEnabled=false で SPEAKING_ROGER と SPEAKING_SCORE をスキップ | speakRoger/speakScore 未呼出、incrementScore 呼出、state: IDLE |

## 予測との比較
| 項目 | 予測 | 実際 | 乖離 |
|------|------|------|------|
| reducer 変更 | `COMMAND_EXECUTED` アクション削除 | `COMMAND_EXECUTED` を型定義・case ブロックから削除 | なし |
| hook 変更 | right/left の dispatch を `COMMAND_EXECUTED_WITH_SCORE` に変更 | switch 後に共通 `dispatch({ type: 'COMMAND_EXECUTED_WITH_SCORE' })` | 微差: switch-case 内ではなく switch 後に 1 回の dispatch に統合（よりクリーン） |
| テスト変更数 | reducer 1件削除、hook 2件変更 | reducer 1件変更(得点加算テスト追加)、hook 4件変更 | hook 側は isSpeechEnabled=false テストも更新が必要だった |
| リスク | 低 | 低（全テスト一発 pass） | なし |

## 意思決定ログ
| 選択肢 | 採用 | 理由 |
|--------|------|------|
| `COMMAND_EXECUTED_WITH_SCORE` をリネームして `COMMAND_EXECUTED` に戻す | 不採用 | `WITH_SCORE` サフィックスが「スコア読み上げ付き」の意図を明確に示す。既存コミット履歴との整合性も考慮 |
| executeCommand() の dispatch を switch-case 内で個別に行う | 不採用 | 全コマンドで同じアクションを dispatch するため、switch 後に 1 回の dispatch に統合する方がDRY |
| pendingCommand 未設定時のフォールバック | `COMMAND_EXECUTED_WITH_SCORE` | 以前は `COMMAND_EXECUTED` で IDLE 直行だったが、統一して SPEAKING_SCORE 経由に変更。実運用でこのパスに入ることはほぼない |

## 学び（Lessons Learned）
- 仕様変更の実装は、コード変更自体は小さくても、テスト側の更新箇所が予測以上に多い場合がある（isSpeechEnabled=false テストのコメント・アサーション修正が必要だった）
- 全コマンドで同じ状態遷移パスを使うように統一したことで、状態マシンが簡素化された（2つの遷移パスが1つに統合）
- TDD の RED フェーズでテストを先に変更し、3件の失敗を確認してから実装に入ることで、変更の正確性を保証できた
