# Task 2.3: スコア操作hookの実装

## Plan（実装前の方針）
- UIとストアの仲介hookとして `useScore` を作成
- ScoreStore（Task 2.2）と GameRules（Task 2.1）を統合
- 得点操作（increment/decrement）後に `checkGameEnd` で試合終了を自動判定
- zundo の `undo()` を `rollback()` として公開、undo 後に isGameEnd を再計算
- `canUndo` を temporal store の `pastStates` からリアクティブに購読
- design.md の `UseScoreReturn` Contract に準拠した公開インターフェース

## 実施内容
- tasks.md の Task 2.3: スコア操作hookの実装
  - UIとストアの仲介hook。得点操作時に試合ルール判定を呼び出し、試合終了を自動判定
  - ロールバック（zundo の undo）とリセットの操作を提供
  - undo可能かどうか（canUndo）の状態を公開
  - テスト: 得点加算→試合終了判定の連携、ロールバック後のスコア確認、試合終了状態でのガード
  - 2.1 と 2.2 の成果物を統合

## 実装結果

### 作成ファイル
| ファイル | 役割 |
|---------|------|
| `src/features/score/hooks/use-score.ts` | useScore hook（ScoreStore + GameRules の統合 UseCase） |
| `src/features/score/hooks/__tests__/use-score.test.ts` | hook のユニットテスト（23テスト） |

### 変更ファイル
| ファイル | 変更内容 |
|---------|----------|
| `.kiro/specs/voice-scoreboard/tasks.md` | Task 2.3 を `[x]` に更新 |

### 公開 API
```typescript
interface UseScoreReturn {
  readonly leftScore: number;
  readonly rightScore: number;
  readonly isGameEnd: boolean;
  readonly canUndo: boolean;
  incrementScore(side: 'left' | 'right'): void;
  decrementScore(side: 'left' | 'right'): void;
  rollback(): void;
  reset(): void;
}
```

### テストケース一覧

#### 初期状態（4テスト）
| ケース | 期待値 |
|--------|--------|
| leftScore | 0 |
| rightScore | 0 |
| isGameEnd | false |
| canUndo | false |

#### incrementScore（3テスト）
| ケース | 期待値 |
|--------|--------|
| 左チーム加算 | leftScore: 1 |
| 右チーム加算 | rightScore: 1 |
| 加算後 canUndo | true |

#### decrementScore（2テスト）
| ケース | 期待値 |
|--------|--------|
| 左チーム減算 | leftScore: 2→1 |
| 右チーム減算 | rightScore: 2→1 |

#### 試合終了判定の連携（4テスト）
| ケース | 期待値 |
|--------|--------|
| 25-0 で試合終了 | isGameEnd: true |
| 25-23 で試合終了 | isGameEnd: true |
| 25-24 は試合継続（デュース） | isGameEnd: false |
| 26-24 で試合終了（デュース後） | isGameEnd: true |

#### 試合終了時のガード（3テスト）
| ケース | 期待値 |
|--------|--------|
| incrementScore が無効 | スコア変化なし |
| decrementScore が無効 | スコア変化なし |
| reset は有効 | 0-0, isGameEnd: false |

#### rollback（4テスト）
| ケース | 期待値 |
|--------|--------|
| 直前の操作を取り消し | leftScore: 1→0 |
| rollback 後 canUndo 更新 | true→false |
| rollback 後 isGameEnd 再計算 | 25-0→24-0 で false |
| 空履歴で rollback | 状態変化なし |

#### reset（3テスト）
| ケース | 期待値 |
|--------|--------|
| 両スコアを0にリセット | leftScore: 0, rightScore: 0 |
| isGameEnd を false に | isGameEnd: false |
| canUndo を false に | canUndo: false |

### 検証結果
- `bun run test` — 86 tests passed（use-score: 23, score-store: 27, game-rules: 30, glow-styles: 5, App: 1）
- リグレッションなし

## 問題点・乖離
- 特になし。Plan の予測通りに実装が完了した

## 意思決定ログ
| 選択肢 | 採用 | 理由 |
|--------|------|------|
| canUndo の購読方法 | `useStore(temporal, selector)` | temporal store は独立した StoreApi であり、`useStore` でリアクティブ購読しないと React の再レンダリングがトリガーされない |
| incrementScore 後の判定タイミング | `getState()` で同期取得 | zustand の `set()` は同期的であり、直後に最新スコアを安全に取得できる |
| rollback 後の isGameEnd | `checkGameEnd` で再計算 | partialize で isGameEnd は undo 履歴から除外されているため、undo 後のスコアで再判定が必要 |
| decrementScore の isGameEnd | 常に再計算して `setGameEnd` | 減算で試合終了条件を満たさなくなる可能性があるため、increment と異なり false への更新も行う |
| ヘルパー関数への共通化 | しない | increment/decrement で判定後の setGameEnd の挙動が微妙に異なる（increment は true のみ設定、decrement は true/false 両方）。2箇所のみで過度な抽象化は不要 |

## 学び（Lessons Learned）
- `useStore(useScoreStore.temporal, selector)` で zundo の temporal store をリアクティブに購読できる。`renderHook` テストでも正しく更新が伝播することを確認
- zustand + zundo + renderHook の組み合わせでは `act()` 内でストア操作すれば `result.current` が最新値を返す
- Plan モードの実装予測が正確であったため、実装はスムーズに完了した
